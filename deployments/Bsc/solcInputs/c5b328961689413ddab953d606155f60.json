{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/BosToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interface/ISwapFactory.sol\";\nimport \"./interface/ISwapPair.sol\";\nimport \"./interface/ISwapRouter.sol\";\nimport \"./interface/IMintPool.sol\";\nimport \"./library/Math.sol\";\nimport \"./interface/IToken.sol\";\nimport \"hardhat/console.sol\";\n\ncontract BosToken is IERC20, OwnableUpgradeable, IToken {\n    struct UserInfo {\n        uint256 lpAmount;\n        bool preLP;\n    }\n\n    mapping(address => uint256) public _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    address public fundAddress;\n\n    mapping(address => bool) public _feeWhiteList;\n\n    mapping(address => UserInfo) private _userInfo;\n\n    uint256 private _tTotal;\n\n    ISwapRouter public _swapRouter;\n\n    mapping(address => bool) public _swapPairList;\n    mapping(address => bool) public _swapRouters;\n\n    bool private inSwap;\n\n    address public _mainPair;\n    address public _usdt;\n\n    bool public _strictCheck;\n\n    bool public _startBuy;\n    bool public _startSell;\n\n    IMintPool public _mintPool;\n    uint256 public _lastGiveRewardTime;\n    uint256 private immutable _giveRewardDuration = 1 days;\n    bool public _pauseGiveReward;\n    uint256 public _giveRewardRate;\n\n    uint256 public _totalMintReward;\n\n    uint256 public _sellPoolRate;\n\n    uint256 public _sellPoolDestroyRate;\n\n    mapping(address => bool) public blacklist;\n\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n\n    function initialize(\n        address _router, \n        address _usdtAddress,\n        uint256 _supply,\n        address _recevie, \n        address _fund,\n        address _owner)\n    external initializer {\n        _name = \"Block Storm\";\n        _symbol = \"BOT\";\n        _decimals = 18;\n        _strictCheck = true;\n        _pauseGiveReward = true;\n        _giveRewardRate = 70;\n        _sellPoolRate = 1000;\n        _sellPoolDestroyRate = 10000;\n\n        ISwapRouter swapRouter = ISwapRouter(_router);\n        _swapRouter = swapRouter;\n        _allowances[address(this)][address(swapRouter)] = type(uint256).max;\n        _swapRouters[address(swapRouter)] = true;\n\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\n        _usdt = _usdtAddress;\n        IERC20(_usdt).approve(address(swapRouter), type(uint256).max);\n        address pair = swapFactory.createPair(address(this), _usdt);\n        _swapPairList[pair] = true;\n        _mainPair = pair;\n\n        uint256 tokenUnit = 10 ** 18;\n        uint256 total = _supply * tokenUnit;\n        _tTotal = total;\n\n        uint256 receiveTotal = total;\n        _balances[_recevie] = receiveTotal;\n        emit Transfer(address(0), _recevie, receiveTotal);\n\n        fundAddress = _fund;\n\n        _feeWhiteList[_recevie] = true;\n        _feeWhiteList[_fund] = true;\n        _feeWhiteList[address(this)] = true;\n        _feeWhiteList[address(swapRouter)] = true;\n        _feeWhiteList[msg.sender] = true;\n        _feeWhiteList[address(0)] = true;\n        _feeWhiteList[0x000000000000000000000000000000000000dEaD] = true;\n        _feeWhiteList[0x9E80518A58442293c607C788c85ea8cC08885C08] = true;\n\n        _transferOwnership(_owner);\n    }\n\n    function symbol() external view  returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external view  returns (string memory) {\n        return _name;\n    }\n\n    function decimals() external view  returns (uint8) {\n        return _decimals;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        require(!blacklist[msg.sender], \"Sender is blacklisted\");\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function giveMintReward() public {\n        if (_pauseGiveReward) {\n            return;\n        }\n        if (block.timestamp < _lastGiveRewardTime + _giveRewardDuration) {\n            return;\n        }\n        IMintPool mintPool = _mintPool;\n        if (address(0) == address(mintPool)) {\n            return;\n        }\n        _lastGiveRewardTime = block.timestamp;\n        uint256 rewardAmount = balanceOf(_mainPair) * _giveRewardRate / 10000;\n        _standTransfer(_mainPair, address(mintPool), rewardAmount);\n        ISwapPair(_mainPair).sync();\n        mintPool.addTotalMintReward(rewardAmount);\n        _totalMintReward += rewardAmount;\n    }\n\n    function updateLPAmount(address account, uint256 lpAmount) public onlyWhiteList {\n        _userInfo[account].lpAmount = lpAmount;\n    }\n\n    function updateLPAmounts(address[] memory account, uint256[] memory lpAmount) public onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            _userInfo[account[i]].lpAmount = lpAmount[i];\n        }\n    }\n\n    function addLPAmount(address account, uint256 lpAmount) public onlyWhiteList {\n        _userInfo[account].lpAmount += lpAmount;\n    }\n\n    function addUserLPAmount(address account, uint256 lpAmount) public {\n        require(msg.sender == address(_mintPool), \"only mint pool\");\n        _userInfo[account].lpAmount += lpAmount;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        }\n        return true;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal - destroySupply();\n    }\n\n    function validSupply() public view returns (uint256) {\n        return totalSupply() - balanceOf(_mainPair);\n    }\n\n    function destroySupply() public view returns (uint256) {\n        return balanceOf(address(0)) + balanceOf(address(0x000000000000000000000000000000000000dEaD));\n    }\n\n    function getTokenInfo() public view returns (\n        uint256 validTotal, uint256 maxTotal, uint256 destroyTotal, uint256 price,\n        uint256 rewardTotal, uint256 nextReward, uint256 usdtDecimals, uint256 tokenDecimals){\n\n        validTotal = validSupply();\n        maxTotal = totalSupply();\n        destroyTotal = destroySupply();\n        price = getTokenPrice();\n        rewardTotal = _totalMintReward;\n        nextReward = balanceOf(_mainPair) * _giveRewardRate / 10000;\n        usdtDecimals = 18;\n        tokenDecimals = _decimals;\n    }\n\n    function getTokenPrice() public view returns (uint256 price){\n        (uint256 rUsdt,uint256 rToken) = __getReserves();\n        if (rToken > 0) {\n            price = 10 ** _decimals * rUsdt / rToken;\n        }\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 balance = balanceOf(from);\n        require(balance >= amount, \"Invalid amount\");\n\n        bool takeFee;\n        if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\n            takeFee = true;\n            uint256 maxSellAmount = balance * 99999 / 100000;\n            if (amount > maxSellAmount) {\n                amount = maxSellAmount;\n            }\n        }\n\n        bool isAddLP;\n        bool isRemoveLP;\n        UserInfo storage userInfo;\n\n        uint256 addLPLiquidity;\n        if (to == _mainPair && _swapRouters[msg.sender]) {\n            addLPLiquidity = _isAddLiquidity(amount);\n            if (addLPLiquidity > 0) {\n                userInfo = _userInfo[from];\n                userInfo.lpAmount += addLPLiquidity;\n                isAddLP = true;\n            }\n        }\n\n        uint256 removeLPLiquidity;\n        if (from == _mainPair) {\n            if (_strictCheck) {\n                removeLPLiquidity = _strictCheckBuy(amount);\n            } else {\n                removeLPLiquidity = _isRemoveLiquidity(amount);\n            }\n            if (removeLPLiquidity > 0) {\n                require(_userInfo[to].lpAmount >= removeLPLiquidity,\"insufficient liquidity\");\n                _userInfo[to].lpAmount -= removeLPLiquidity;\n                isRemoveLP = true;\n            }\n        }\n\n        _tokenTransfer(from, to, amount, takeFee, isRemoveLP, isAddLP);\n    }\n\n    function _isAddLiquidity(uint256 amount) internal view returns (uint256 liquidity){\n        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();\n        uint256 amountOther;\n        if (rOther > 0 && rThis > 0) {\n            amountOther = amount * rOther / rThis;\n        }\n        //isAddLP\n        if (balanceOther >= rOther + amountOther) {\n            (liquidity,) = calLiquidity(balanceOther, amount, rOther, rThis);\n        }\n    }\n\n    function _strictCheckBuy(uint256 amount) internal view returns (uint256 liquidity){\n        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();\n        //isRemoveLP\n        if (balanceOther < rOther) {\n            liquidity = (amount * ISwapPair(_mainPair).totalSupply()) /\n            (_balances[_mainPair] - amount);\n        } else {\n            uint256 amountOther;\n            if (rOther > 0 && rThis > 0) {\n                amountOther = amount * rOther / (rThis - amount);\n                //strictCheckBuy\n                require(balanceOther >= amountOther + rOther,\"insufficient liquidity\");\n            }\n        }\n    }\n\n    function calLiquidity(\n        uint256 balanceA,\n        uint256 amount,\n        uint256 r0,\n        uint256 r1\n    ) private view returns (uint256 liquidity, uint256 feeToLiquidity) {\n        uint256 pairTotalSupply = ISwapPair(_mainPair).totalSupply();\n        address feeTo = ISwapFactory(_swapRouter.factory()).feeTo();\n        bool feeOn = feeTo != address(0);\n        uint256 _kLast = ISwapPair(_mainPair).kLast();\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(r0 * r1);\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = pairTotalSupply * (rootK - rootKLast) * 8;\n                    uint256 denominator = rootK * 17 + (rootKLast * 8);\n                    feeToLiquidity = numerator / denominator;\n                    if (feeToLiquidity > 0) pairTotalSupply += feeToLiquidity;\n                }\n            }\n        }\n        uint256 amount0 = balanceA - r0;\n        if (pairTotalSupply == 0) {\n            liquidity = Math.sqrt(amount0 * amount) - 1000;\n        } else {\n            liquidity = Math.min(\n                (amount0 * pairTotalSupply) / r0,\n                (amount * pairTotalSupply) / r1\n            );\n        }\n    }\n\n    function _getReserves() public view returns (uint256 rOther, uint256 rThis, uint256 balanceOther){\n        (rOther, rThis) = __getReserves();\n        balanceOther = IERC20(_usdt).balanceOf(_mainPair);\n    }\n\n    function __getReserves() public view returns (uint256 rOther, uint256 rThis){\n        ISwapPair mainPair = ISwapPair(_mainPair);\n        (uint r0, uint256 r1,) = mainPair.getReserves();\n\n        address tokenOther = _usdt;\n        if (tokenOther < address(this)) {\n            rOther = r0;\n            rThis = r1;\n        } else {\n            rOther = r1;\n            rThis = r0;\n        }\n    }\n\n    function _isRemoveLiquidity(uint256 amount) internal view returns (uint256 liquidity){\n        (uint256 rOther, , uint256 balanceOther) = _getReserves();\n        //isRemoveLP\n        if (balanceOther < rOther) {\n            liquidity = (amount * ISwapPair(_mainPair).totalSupply()) /\n            (_balances[_mainPair] - amount);\n        }\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount,\n        bool takeFee,\n        bool isRemoveLP,\n        bool isAddLP\n    ) private {\n        uint256 senderBalance = _balances[sender];\n        senderBalance -= tAmount;\n        _balances[sender] = senderBalance;\n\n        if (isRemoveLP) {\n\n        } else if (isAddLP) {\n            if (takeFee) {\n                require(_startSell,\"only start sell\");\n            }\n        } else if (_swapPairList[sender]) {//Buy\n            if (takeFee) {\n                require(_startBuy && recipient != address(_swapRouter),\"only start buy and not swapRouter\");\n            }\n        } else if (_swapPairList[recipient]) {//Sell\n            if (takeFee) {\n                require(_startSell,\"only start sell\");\n            }\n            uint256 poolToken = balanceOf(recipient);\n            require(tAmount <= poolToken * _sellPoolRate / 10000, \"not enough poolToken\");\n\n            uint256 poolDestroyAmount = tAmount * _sellPoolDestroyRate / 10000;\n            if (poolDestroyAmount > 0) {\n                _standTransfer(recipient, address(0x000000000000000000000000000000000000dEaD), poolDestroyAmount);\n                ISwapPair(recipient).sync();\n            }\n        } else {//Transfer\n\n        }\n\n        _takeTransfer(sender, recipient, tAmount);\n    }\n\n    function _standTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        _takeTransfer(sender, recipient, tAmount);\n    }\n\n    function _takeTransfer(\n        address sender,\n        address to,\n        uint256 tAmount\n    ) private {\n        _balances[to] = _balances[to] + tAmount;\n        emit Transfer(sender, to, tAmount);\n    }\n\n    modifier onlyWhiteList() {\n        address msgSender = msg.sender;\n        require(_feeWhiteList[msgSender] && (msgSender == fundAddress || msgSender == owner()), \"only white list\");\n        _;\n    }\n\n    function setFundAddress(address addr) external onlyWhiteList {\n        fundAddress = addr;\n        _feeWhiteList[addr] = true;\n    }\n\n    function setFeeWhiteList(address addr, bool enable) external onlyWhiteList {\n        _feeWhiteList[addr] = enable;\n    }\n\n    function batchSetFeeWhiteList(address [] memory addr, bool enable) external onlyWhiteList {\n        for (uint i = 0; i < addr.length; i++) {\n            _feeWhiteList[addr[i]] = enable;\n        }\n    }\n\n    function setSwapPairList(address addr, bool enable) external onlyWhiteList {\n        _swapPairList[addr] = enable;\n    }\n\n    function setSwapRouter(address addr, bool enable) external onlyWhiteList {\n        _swapRouters[addr] = enable;\n    }\n\n    function claimBalance() external {\n        safeTransferETH(fundAddress, address(this).balance);\n    }\n\n    function claimToken(address token, uint256 amount) external {\n        if (_feeWhiteList[msg.sender]) {\n            safeTransferToken(token, fundAddress, amount);\n        }\n    }\n\n    function safeTransferToken(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'transfer fail');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value : value}(new bytes(0));\n        require(success, 'transfer fail');\n    }\n\n    receive() external payable {}\n\n    function setStrictCheck(bool enable) external onlyWhiteList {\n        _strictCheck = enable;\n    }\n\n    function getUserInfo(address account) public view returns (uint256 lpAmount, uint256 lpBalance) {\n        lpAmount = _userInfo[account].lpAmount;\n        lpBalance = IERC20(_mainPair).balanceOf(account);\n    }\n\n    function setStartBuy(bool enable) external onlyWhiteList {\n        _startBuy = enable;\n    }\n\n    function setStartSell(bool enable) external onlyWhiteList {\n        _startSell = enable;\n    }\n\n\n    function setSellPoolRate(uint256 rate) external onlyWhiteList {\n        _sellPoolRate = rate;\n    }\n\n    function setSellPoolDestroyRate(uint256 rate) external onlyWhiteList {\n        _sellPoolDestroyRate = rate;\n    }\n\n    function setMinPool(address p) public onlyWhiteList {\n        _mintPool = IMintPool(p);\n        _feeWhiteList[p] = true;\n    }\n\n    function setLastGiveRewardTime(uint256 t) public onlyWhiteList {\n        _lastGiveRewardTime = t;\n    }\n\n    function setPauseGiveReward(bool p) public onlyWhiteList {\n        _pauseGiveReward = p;\n    }\n\n    function setGiveRewardRate(uint256 r) public onlyWhiteList {\n        _giveRewardRate = r;\n    }\n\n    function mint(address account, uint256 amount) external onlyOwner {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _tTotal += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n    }\n\n    function addToBlacklist(address _user) external onlyOwner {\n        blacklist[_user] = true;\n    }\n\n    function removeFromBlacklist(address _user) external onlyOwner {\n        blacklist[_user] = false;\n    }\n}"
    },
    "contracts/interface/IMintPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n\ninterface IMintPool {\n    function addTotalMintReward(uint256 reward) external;\n    function getUserNFTLevel(address account) external view returns (uint256);\n}"
    },
    "contracts/interface/INFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n\ninterface INFT {\n    function addTokenReward(uint256 rewardAmount) external;\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n}"
    },
    "contracts/interface/ISwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n\ninterface ISwapFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function feeTo() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n"
    },
    "contracts/interface/ISwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface ISwapPair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function totalSupply() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function sync() external;\n}"
    },
    "contracts/interface/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface ISwapRouter {\n    function factory() external pure returns (address);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n    external\n    view\n    returns (uint256[] memory amounts);\n}"
    },
    "contracts/interface/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n\ninterface IToken {\n    function giveMintReward() external;\n\n    function addUserLPAmount(address account, uint256 lpAmount) external;\n}\n"
    },
    "contracts/library/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}"
    },
    "contracts/MintPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport \"./interface/INFT.sol\";\nimport \"./interface/ISwapRouter.sol\";\nimport \"./interface/ISwapFactory.sol\";\nimport \"./interface/ISwapPair.sol\";\nimport \"./interface/IToken.sol\";\nimport \"hardhat/console.sol\";\n\n\ncontract MintPool is Ownable, Initializable {\n    struct UserInfo {\n        bool isActive;  \n        uint256 amount; \n        uint256 rewardMintDebt; \n        uint256 calMintReward;  \n    }\n\n    struct PoolInfo {\n        uint256 totalAmount;\n        uint256 accMintPerShare;\n        uint256 accMintReward;\n        uint256 mintPerSec;\n        uint256 lastMintTime;\n        uint256 totalMintReward;\n    }\n\n    struct UserLPInfo {\n        uint256 lockAmount;\n        uint256 calAmount;\n        uint256 claimedAmount;\n        uint256 lastReleaseTime;\n        uint256 releaseInitAmount;\n        uint256 releaseDuration;\n        uint256 speedUpTime;\n    }\n\n    PoolInfo public poolInfo;\n    mapping(address => UserInfo) public userInfo;\n    mapping(address => UserLPInfo) public _userLPInfo;\n\n    ISwapRouter private _swapRouter;\n    address private _usdt;             \n    uint256 private _minAmount;\n    address private _mintRewardToken;  \n    address public  _lp;\n    INFT public _nft;\n\n    mapping(address => address) public _invitor; \n    mapping(address => address[]) public _binder; \n    mapping(uint256 => uint256) public _inviteFee;\n    uint256 private immutable _inviteLen = 3;\n    address private _defaultInvitor;\n\n    mapping(address => uint256) public _inviteAmount;\n    mapping(address => uint256) public _teamAmount;\n    mapping(address => uint256) public _teamNum;  \n\n    bool public _pauseSell;\n    uint256 public _sellSelfRate;\n    uint256 public _sellJoinRate;\n    uint256 public _sellNFTRate;\n    address public _sellLPReceiver;\n    mapping(address => uint256) private _sellJoinAmount;\n    address public _fundAddress;\n\n    mapping(address => address[]) public referrals;  \n    mapping(address => address) public superAccount; \n    mapping(address => uint256) public referralAmount;  \n    mapping(address => uint256) public depositAmount;   \n    mapping(address => uint256) public referralReward;\n    mapping(address => uint256) public userLevel;\n\n    uint256 public immutable v1Amount = 2500 ether;\n    uint256 public immutable v2Amount = 20000 ether;\n    uint256 public immutable v3Amount = 50000 ether;\n    uint256 public immutable v4Amount = 150000 ether;\n    uint256 public immutable v5Amount = 500000 ether;\n\n    bool private _pauseJoin;\n    uint256 public _lastDailyUpTime;\n    uint256 public _lastAmountRate;\n    uint256 public _amountDailyUp;\n    uint256 private immutable _divFactor = 10000;\n    uint256 private immutable _dailyDuration = 1 days;\n\n    uint256 public _lpReleaseDuration;\n    //\n    uint256 private _speedUpCost;\n    uint256 public _speedUpDuration;\n    address public _speedUpReceiver;\n    uint256 private _speedUpMaxTime;\n    uint256 private _totalUsdt;\n\n    mapping(address => bool) public _inProject;\n    uint256 private _lastDailyReward;\n\n\n    event nftTokenReward(address indexed account, uint256 indexed level, uint256 indexed tokenAmount);\n    event nftPowerReward(address indexed account, uint256 indexed level, uint256 indexed powerAmount);\n    event Deposit(address indexed account, uint256 indexed amount);\n    event Sell(address indexed account, uint256 indexed tokenAmount, uint256 indexed selfAmount);\n\n\n    // ******** modifier *********\n\n    modifier onlyWhiteList() {\n        require(\n            msg.sender == _fundAddress ||\n            msg.sender == owner() ||\n            msg.sender == address(_nft),\n            \"only white list\"\n        );\n        _;\n    }\n\n    modifier onlyInProject() {\n        require(_inProject[msg.sender] || msg.sender == owner(), \"only project\");\n        _;\n    }\n\n\n    // ******** constructor *********\n    function initialize(\n        address swapRouter,\n        address usdt,\n        address mintRewardToken,\n        address nft,\n        address defaultInvitor,\n        address fundAddress,\n        address _owner\n    ) external initializer {\n        _pauseJoin = true;\n        _swapRouter = ISwapRouter(swapRouter);\n        _usdt = usdt;\n        _minAmount = 10 ether;\n        _nft = INFT(nft);\n        _mintRewardToken = mintRewardToken;\n\n        _lp = ISwapFactory(_swapRouter.factory()).getPair(usdt, mintRewardToken);\n\n        poolInfo.lastMintTime = block.timestamp;\n        _defaultInvitor = defaultInvitor;\n        userInfo[defaultInvitor].isActive = true;\n\n        _inviteFee[0] = 800;\n        // 8%\n        _inviteFee[1] = 500;\n        // 5%\n        _inviteFee[2] = 300;\n        // 3%\n\n        _speedUpCost = 300 ether;\n\n        safeApprove(usdt, swapRouter, ~uint256(0));\n        safeApprove(mintRewardToken, swapRouter, ~uint256(0));\n        _sellLPReceiver = fundAddress;\n        _fundAddress = fundAddress;\n        _speedUpMaxTime = 3;\n        _speedUpReceiver = 0x000000000000000000000000000000000000dEaD;\n\n        _sellSelfRate = 5000;\n        _sellJoinRate = 4000;\n        _sellNFTRate = 500;\n\n        _lastAmountRate = 10000;\n        _amountDailyUp = 10100;\n        _lpReleaseDuration = 90 days;\n        _speedUpDuration = 10 days;\n\n        _transferOwnership(_owner);\n    }\n\n    receive() external payable {}\n\n\n    // ******** public *********\n    // function sell(uint256 tokenAmount) public {\n    //     require(msg.sender == tx.origin, \"not Origin\");\n    //     require(!_pauseSell, \"pause\");\n\n    //     _bindInvitor(msg.sender, _defaultInvitor);\n    //     _takeToken(_mintRewardToken, msg.sender, address(this), tokenAmount);\n\n    //     IERC20 USDT = IERC20(_usdt);\n    //     uint256 usdtBalanceBefore = USDT.balanceOf(address(this));\n\n    //     address[] memory path = new address[](2);\n    //     path[0] = _mintRewardToken;\n    //     path[1] = _usdt;\n\n    //     _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    //         tokenAmount,\n    //         0,\n    //         path,\n    //         address(this),\n    //         block.timestamp\n    //     );\n\n    //     uint256 usdtAmount = USDT.balanceOf(address(this)) - usdtBalanceBefore;\n    //     uint256 selfUsdt = (usdtAmount * _sellSelfRate) / 10000;\n    //     _giveToken(_usdt, msg.sender, selfUsdt);\n\n    //     uint256 sellJoinUsdt = (usdtAmount * _sellJoinRate) / 10000;\n    //     addLP(msg.sender, sellJoinUsdt, 0, false);\n\n    //     _updatePool();\n    //     uint256 sellJoinAmount = (sellJoinUsdt * _lastAmountRate) / _divFactor;\n    //     _addUserAmount(msg.sender, sellJoinAmount, false);\n    //     _sellJoinAmount[msg.sender] += sellJoinAmount;\n\n    //     uint256 nftUsdt = (usdtAmount * _sellNFTRate) / 10000;\n    //     _giveToken(_usdt, address(_nft), nftUsdt);\n    //     _nft.addTokenReward(nftUsdt);\n\n    //     uint256 fundUsdt = usdtAmount - selfUsdt - sellJoinUsdt - nftUsdt;\n    //     _giveToken(_usdt, _fundAddress, fundUsdt);\n\n    //     IToken(_mintRewardToken).giveMintReward();\n\n    //     emit Sell(msg.sender, tokenAmount, selfUsdt);\n    // }\n\n\n    //    function deposit(uint256 amount, uint256 minTokenAmount, address invitor) external {\n    //        require(!_pauseJoin, \"deposit pause\");\n    //        require(amount >= _minAmount, \"deposit too low\");\n\n    //        address account = msg.sender;\n    //        require(account == msg.sender, \"deposit not origin\");\n\n    //        _totalUsdt += amount;\n\n    //        _bindInvitor(account, invitor);\n\n    //        _takeToken(_usdt, account, address(this), amount);\n\n    //        addLP(account, amount, minTokenAmount, true);\n\n    //        _updatePool();\n\n    //        _addUserAmount(account, (amount * _lastAmountRate) / _divFactor, true);\n\n    //        IToken(_mintRewardToken).giveMintReward();\n\n    //        distributeNFTRewards(invitor, amount);\n\n    //        addReferral(amount, account, invitor);\n\n    //        emit Deposit(account, amount);\n    //    }\n\n\n    //    function claim() public {\n    //        UserInfo storage user = userInfo[msg.sender];\n\n    //        _calReward(user, true);\n    //        uint256 pendingMint = user.calMintReward;\n\n    //        if (pendingMint > 0) {\n    //            _giveToken(_mintRewardToken, msg.sender, pendingMint);\n    //            user.calMintReward = 0;\n    //        }\n\n    //        IToken(_mintRewardToken).giveMintReward();\n    //    }\n\n\n    //    function claimLP() public {\n    //        require(msg.sender == tx.origin, \"claimLP not Origin\");\n\n    //        UserLPInfo storage userLPInfo = _userLPInfo[msg.sender];\n    //        uint256 nowTime = block.timestamp;\n\n    //        if (userLPInfo.lastReleaseTime > 0 && nowTime > userLPInfo.lastReleaseTime) {\n    //            uint256 releaseAmount = (userLPInfo.releaseInitAmount * (nowTime - userLPInfo.lastReleaseTime)) / userLPInfo.releaseDuration;\n    //            uint256 maxAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\n    //            if (releaseAmount > maxAmount) {\n    //                releaseAmount = maxAmount;\n    //            }\n    //            userLPInfo.calAmount += releaseAmount;\n    //        }\n\n    //        uint256 calAmount = userLPInfo.calAmount;\n\n    //        if (calAmount > 0) {\n    //            _giveToken(_lp, msg.sender, calAmount);\n    //            userLPInfo.calAmount = 0;\n    //            userLPInfo.claimedAmount += calAmount;\n    //            IToken(_mintRewardToken).addUserLPAmount(msg.sender, calAmount);\n    //        }\n\n    //        if (nowTime > userLPInfo.lastReleaseTime) {\n    //            userLPInfo.lastReleaseTime = nowTime;\n    //        }\n\n    //        IToken(_mintRewardToken).giveMintReward();\n    //    }\n\n\n    function checkForLevelUp(address invitor) public {\n        if (referrals[invitor].length > 1) {\n            uint256 totalReferralAmount = referralAmount[invitor] + depositAmount[invitor];\n            uint256 currentLevel = userLevel[invitor];\n            uint256[5] memory amountCheckArray = [v1Amount * 2, v2Amount, v3Amount, v4Amount, v5Amount];\n            if (checkLevelCount(invitor, amountCheckArray, totalReferralAmount, currentLevel) && currentLevel < 5) {\n                userLevel[invitor] = currentLevel + 1;\n            }\n        }\n    }\n\n    function getPendingMintReward(address account) public view returns (uint256 reward) {\n        PoolInfo storage pool = poolInfo;\n        UserInfo storage user = userInfo[account];\n\n        if (user.amount > 0) {\n            uint256 blockTime = block.timestamp;\n            uint256 lastRewardTime = pool.lastMintTime;\n\n            if (blockTime > lastRewardTime) {\n                uint256 poolPendingReward = pool.mintPerSec * (blockTime - lastRewardTime);\n                uint256 totalReward = pool.totalMintReward;\n                uint256 accReward = pool.accMintReward;\n                uint256 remainReward = (totalReward > accReward) ? (totalReward - accReward) : 0;\n\n                poolPendingReward = (poolPendingReward > remainReward) ? remainReward : poolPendingReward;\n\n                reward = (user.amount * (pool.accMintPerShare + (poolPendingReward * 1e18) / pool.totalAmount)) / 1e18 - user.rewardMintDebt;\n            }\n        }\n\n        return reward;\n    }\n\n\n    function updateDailyUpRate() public {\n        uint256 lastDailyUpTime = _lastDailyUpTime;\n        if (0 == lastDailyUpTime) {\n            return;\n        }\n        uint256 dailyDuration = _dailyDuration;\n        uint256 nowTime = block.timestamp;\n        if (nowTime < lastDailyUpTime + dailyDuration) {\n            return;\n        }\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\n        _lastDailyUpTime = lastDailyUpTime + ds * dailyDuration;\n\n        uint256 lastAmountRate = _lastAmountRate;\n        lastAmountRate = (lastAmountRate * _amountDailyUp ** ds) / _divFactor ** ds;\n        _lastAmountRate = lastAmountRate;\n    }\n\n    function speedUpLP(uint256 maxTokenAmount) public {\n        require(msg.sender == tx.origin, \"not Origin\");\n        UserLPInfo storage userLPInfo = _userLPInfo[msg.sender];\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\n        uint256 nowTime = block.timestamp;\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\n            uint256 releaseAmount = (userLPInfo.releaseInitAmount *\n            (nowTime - lastReleaseTime)) / userLPInfo.releaseDuration;\n            uint256 maxAmount = userLPInfo.lockAmount -\n            userLPInfo.calAmount -\n            userLPInfo.claimedAmount;\n            if (releaseAmount > maxAmount) {\n                releaseAmount = maxAmount;\n            }\n            userLPInfo.calAmount += releaseAmount;\n        }\n\n        if (nowTime > lastReleaseTime) {\n            userLPInfo.lastReleaseTime = nowTime;\n        }\n\n        require(userLPInfo.speedUpTime < _speedUpMaxTime, \"speedUpTime is max\");\n        userLPInfo.speedUpTime++;\n        uint256 tokenAmount = getSpeedUpTokenAmount();\n        require(tokenAmount <= maxTokenAmount, \"token amount is too much\");\n        _takeToken(_mintRewardToken, msg.sender, _speedUpReceiver, tokenAmount);\n\n        //\n        uint256 remainAmount = userLPInfo.lockAmount -\n        userLPInfo.calAmount -\n        userLPInfo.claimedAmount;\n        uint256 remainDuration = (remainAmount * userLPInfo.releaseDuration) /\n        userLPInfo.releaseInitAmount;\n\n        //\n        userLPInfo.releaseInitAmount = remainAmount;\n        uint256 speedUpDuration = _speedUpDuration;\n        require(remainDuration > speedUpDuration, \"releaseDuration is too short\");\n        userLPInfo.releaseDuration = remainDuration - speedUpDuration;\n\n        IToken(_mintRewardToken).giveMintReward();\n    }\n\n    // ******** private *********\n    function checkLevelCount(address invitor, uint[5] memory amountCheckArray, uint totalReferralAmount, uint currentLevel)\n    internal view returns (bool) {\n        address[] memory referralArr = referrals[invitor];\n        if (totalReferralAmount >= amountCheckArray[currentLevel]) {\n            uint cnt = 0;\n            for (uint256 i; i < referrals[invitor].length; ++i) {\n                if (currentLevel == 0) {\n                    if (referralAmount[referralArr[i]] + depositAmount[referralArr[i]] >= v1Amount) {\n                        ++cnt;\n                    }\n                } else {\n                    if (userLevel[referralArr[i]] >= 1) {\n                        ++cnt;\n                    }\n                }\n                if (cnt >= 2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    // Give NFT reward\n    function distributeNFTRewards(address invitor, uint256 amount) private {\n        uint256 invLevel = userLevel[invitor];\n        uint256 nBalance = _nft.balanceOf(invitor);\n        uint256 rewardAmount = calculateNFTReward(invLevel, amount);\n\n        if (invLevel > 0 && nBalance > 0) {\n            distributeMainReward(invitor, rewardAmount);\n            distributeSuperRewards(invitor, invLevel, amount);\n        } else {\n            // Loop super wallet\n            address currentAccount = superAccount[invitor];\n            bool hasNFT = false;\n            while (currentAccount != address(0) && !hasNFT) {\n                uint256 sLevel = userLevel[currentAccount];\n                uint256 sBalance = _nft.balanceOf(currentAccount);\n                if (sLevel > 0 && sBalance > 0) {\n                    hasNFT = true;\n                    rewardAmount = calculateNFTReward(sLevel, amount);\n                    distributeMainReward(currentAccount, rewardAmount);\n                    distributeSuperRewards(currentAccount, sLevel, amount);\n                }\n                if (currentAccount == superAccount[currentAccount]) {\n                    currentAccount = address(0);\n                } else {\n                    currentAccount = superAccount[currentAccount];\n                }\n            }\n        }\n    }\n\n    function distributeMainReward(address invitor, uint256 rewardAmount) private {\n        // Add power\n        uint256 addAmount = (rewardAmount * _lastAmountRate) / _divFactor;\n        _addUserAmount(invitor, addAmount, false);\n\n        uint256 level = userLevel[invitor];\n        emit nftPowerReward(invitor, level, addAmount);\n\n        // Give token\n        _giveToken(_usdt, invitor, rewardAmount);\n\n        emit nftTokenReward(invitor, level, rewardAmount);\n    }\n\n    function distributeSuperRewards(address invitor, uint256 invLevel, uint256 amount) private {\n        address currentAccount = superAccount[invitor];\n        uint256 nextLevel = invLevel;\n        uint256 sameLevel = invLevel + 1;\n\n        while (currentAccount != address(0) && nextLevel <= 5) {\n            uint256 sLevel = userLevel[currentAccount];\n            uint256 sAmount = calculateNFTReward(sLevel, amount);\n\n            if (sLevel > nextLevel || sLevel == sameLevel) {\n                distributeSuperReward(currentAccount, sAmount);\n                nextLevel = sLevel;\n                sameLevel = sLevel + 1;\n            } else if (sLevel == nextLevel) {\n                distributeSameLevelReward(currentAccount, sAmount);\n                nextLevel = sLevel + 1;\n            }\n            if (currentAccount == superAccount[currentAccount]) {\n                currentAccount = address(0);\n            } else {\n                currentAccount = superAccount[currentAccount];\n            }\n        }\n    }\n\n    function distributeSuperReward(address invitor, uint256 sAmount) private {\n        // Add power\n        uint256 srAmount = (sAmount * _lastAmountRate) / _divFactor;\n        _addUserAmount(invitor, srAmount, false);\n\n        uint256 level = userLevel[invitor];\n        emit nftPowerReward(invitor, level, srAmount);\n\n        // Give token\n        _giveToken(_usdt, invitor, sAmount);\n\n        emit nftTokenReward(invitor, level, sAmount);\n    }\n\n    function distributeSameLevelReward(address invitor, uint256 sAmount) private {\n        // Same level 20% rewards\n        uint256 srAmount = (sAmount * _lastAmountRate) / _divFactor;\n        uint256 sameLevelAmount = (srAmount * 20) / 100;\n\n        // Add power\n        _addUserAmount(invitor, sameLevelAmount, false);\n\n        uint256 level = userLevel[invitor];\n        emit nftPowerReward(invitor, level, sameLevelAmount);\n\n        // Token reward\n        uint256 tokenAmount = (sAmount * 20) / 100;\n        _giveToken(_usdt, invitor, tokenAmount);\n\n        emit nftTokenReward(invitor, level, tokenAmount);\n    }\n\n    // NFT add ref\n    function addReferral(uint256 amount, address account, address invitor) private {\n        depositAmount[account] += amount;\n\n        address currentAccount = invitor;\n        while (currentAccount != address(0)) {\n            referralAmount[currentAccount] += amount;\n            checkForLevelUp(currentAccount);\n            if (currentAccount == superAccount[currentAccount]) {\n                currentAccount = address(0);\n            }\n            currentAccount = superAccount[currentAccount];\n        }\n    }\n\n    function addLP(address account, uint256 usdtAmount, uint256 minTokenAmount, bool lockLP) private {\n        address token = _mintRewardToken;\n        IERC20 Token = IERC20(token);\n        uint256 tokenBalanceBefore = Token.balanceOf(address(this));\n\n        address usdt = _usdt;\n        address[] memory path = new address[](2);\n        path[0] = usdt;\n        path[1] = token;\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            usdtAmount / 2,\n            minTokenAmount,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 tokenAmount = Token.balanceOf(address(this)) - tokenBalanceBefore;\n\n        address lpReceiver = lockLP ? address(this) : _sellLPReceiver;\n        (, , uint256 liquidity) = _swapRouter.addLiquidity(\n            usdt,\n            token,\n            usdtAmount / 2,\n            tokenAmount,\n            0,\n            0,\n            lpReceiver,\n            block.timestamp\n        );\n        //\n        if (lockLP) {\n            _addLockLP(account, liquidity);\n        } else {\n            IToken(_mintRewardToken).addUserLPAmount(lpReceiver, liquidity);\n        }\n    }\n\n    function _addLockLP(address account, uint256 liquidity) private {\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\n        uint256 nowTime = block.timestamp;\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\n            uint256 releaseAmount = (userLPInfo.releaseInitAmount * (nowTime - lastReleaseTime)) / userLPInfo.releaseDuration;\n            uint256 maxAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\n            if (releaseAmount > maxAmount) {\n                releaseAmount = maxAmount;\n            }\n            userLPInfo.calAmount += releaseAmount;\n        }\n        uint256 remainAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\n        userLPInfo.lockAmount += liquidity;\n        userLPInfo.releaseInitAmount = remainAmount + liquidity;\n        userLPInfo.releaseDuration = _lpReleaseDuration;\n\n        if (nowTime > lastReleaseTime) {\n            userLPInfo.lastReleaseTime = nowTime;\n        }\n    }\n\n    function _addUserAmount(address account, uint256 amount, bool calInvite) private {\n        UserInfo storage user = userInfo[account];\n        _calReward(user, false);\n\n        uint256 userAmount = user.amount;\n        userAmount += amount;\n        user.amount = userAmount;\n\n        uint256 poolTotalAmount = poolInfo.totalAmount;\n        poolTotalAmount += amount;\n\n        uint256 poolAccMintPerShare = poolInfo.accMintPerShare;\n        user.rewardMintDebt = (userAmount * poolAccMintPerShare) / 1e18;\n\n        if (calInvite) {\n            uint256 len = _inviteLen;\n            UserInfo storage invitorInfo;\n            address current = account;\n            address invitor;\n            uint256 invitorTotalAmount;\n            for (uint256 i; i < len; ++i) {\n                invitor = _invitor[current];\n                if (address(0) == invitor) {\n                    break;\n                }\n                invitorInfo = userInfo[invitor];\n                _calReward(invitorInfo, false);\n                uint256 inviteAmount = (amount * _inviteFee[i]) / 10000;\n                _inviteAmount[invitor] += inviteAmount;\n                _teamAmount[invitor] += amount;\n\n                invitorTotalAmount = invitorInfo.amount;\n                invitorTotalAmount += inviteAmount;\n                invitorInfo.amount = invitorTotalAmount;\n                invitorInfo.rewardMintDebt = (invitorTotalAmount * poolAccMintPerShare) / 1e18;\n\n                poolTotalAmount += inviteAmount;\n                current = invitor;\n            }\n        }\n        poolInfo.totalAmount = poolTotalAmount;\n    }\n\n    function _updatePool() private {\n        updateDailyUpRate();\n        PoolInfo storage pool = poolInfo;\n        uint256 blockTime = block.timestamp;\n        uint256 lastRewardTime = pool.lastMintTime;\n        if (blockTime <= lastRewardTime) {\n            return;\n        }\n        pool.lastMintTime = blockTime;\n\n        uint256 accReward = pool.accMintReward;\n        uint256 totalReward = pool.totalMintReward;\n        if (accReward >= totalReward) {\n            return;\n        }\n\n        uint256 totalAmount = pool.totalAmount;\n        uint256 rewardPerSec = pool.mintPerSec;\n        if (0 < totalAmount && 0 < rewardPerSec) {\n            uint256 reward = rewardPerSec * (blockTime - lastRewardTime);\n            uint256 remainReward = totalReward - accReward;\n            if (reward > remainReward) {\n                reward = remainReward;\n            }\n            pool.accMintPerShare += (reward * 1e18) / totalAmount;\n            pool.accMintReward += reward;\n        }\n    }\n\n    function _calReward(UserInfo storage user, bool updatePool) private {\n        if (updatePool) {\n            _updatePool();\n        }\n        if (user.amount > 0) {\n            uint256 accMintReward = (user.amount * poolInfo.accMintPerShare) / 1e18;\n            uint256 pendingMintAmount = accMintReward - user.rewardMintDebt;\n            if (pendingMintAmount > 0) {\n                user.rewardMintDebt = accMintReward;\n                user.calMintReward += pendingMintAmount;\n            }\n        }\n    }\n\n\n    // ******** view *********\n    function getDailyRate() private view returns (uint256) {\n        uint256 lastAmountRate = _lastAmountRate;\n        uint256 lastDailyUpTime = _lastDailyUpTime;\n        if (0 == lastDailyUpTime) {\n            return lastAmountRate;\n        }\n        uint256 dailyDuration = _dailyDuration;\n        uint256 nowTime = block.timestamp;\n        if (nowTime < lastDailyUpTime + dailyDuration) {\n            return lastAmountRate;\n        }\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\n\n        uint256 amountDailyUp = _amountDailyUp;\n        for (uint256 i; i < ds; ++i) {\n            lastAmountRate = (lastAmountRate * amountDailyUp) / _divFactor;\n        }\n        return lastAmountRate;\n    }\n\n    function calculateNFTReward(uint256 userRewardLevel, uint256 amount) public pure returns (uint256){\n        if (userRewardLevel == 0 || userRewardLevel > 5) {\n            return 0;\n        }\n        return (amount * userRewardLevel) / 100;\n    }\n\n    function getSpeedUpTokenAmount() private view returns (uint256 tokenAmount){\n        (uint256 rUsdt, uint256 rToken) = _getReserves();\n        tokenAmount = (_speedUpCost * rToken) / rUsdt;\n    }\n\n    function _getReserves() public view returns (uint256 rUsdt, uint256 rToken){\n        ISwapPair pair = ISwapPair(_lp);\n        (uint256 r0, uint256 r1,) = pair.getReserves();\n\n        if (_usdt < _mintRewardToken) {\n            rUsdt = r0;\n            rToken = r1;\n        } else {\n            rUsdt = r1;\n            rToken = r0;\n        }\n    }\n\n    function getJoinTokenAmountOut(uint256 usdtAmount) public view returns (uint256 tokenAmount){\n        address[] memory path = new address[](2);\n        path[0] = _usdt;\n        path[1] = _mintRewardToken;\n        uint256[] memory amounts = _swapRouter.getAmountsOut(\n            usdtAmount / 2,\n            path\n        );\n        tokenAmount = amounts[1];\n    }\n\n    function getSellUsdtOut(uint256 tokenAmount) public view\n    returns (uint256 usdtAmount, uint256 selfUsdt, uint256 mintAmount){\n        address[] memory path = new address[](2);\n        path[0] = _mintRewardToken;\n        path[1] = _usdt;\n        uint256[] memory amounts = _swapRouter.getAmountsOut(tokenAmount, path);\n        usdtAmount = amounts[1];\n        selfUsdt = (usdtAmount * _sellSelfRate) / 10000;\n        mintAmount = (usdtAmount * _sellJoinRate) / 10000;\n        mintAmount = (mintAmount * getDailyRate()) / 10000;\n    }\n\n    function getBinderLength(address account) public view returns (uint256) {\n        return _binder[account].length;\n    }\n\n    // NFT level\n    function getUserNFTLevel(address account) external view returns (uint256) {\n        return userLevel[account];\n    }\n\n    //\n    function _bindInvitor(address account, address invitor) private {\n        UserInfo storage user = userInfo[account];\n        if (!user.isActive) {\n            require(address(0) != invitor, \"invitor 0\");\n            require(userInfo[invitor].isActive, \"invitor !Active\");\n            //nft refer\n            referrals[invitor].push(account);\n            superAccount[account] = invitor;\n\n            _invitor[account] = invitor;\n            _binder[invitor].push(account);\n            for (uint256 i; i < _inviteLen;) {\n                _teamNum[invitor] += 1;\n                invitor = _invitor[invitor];\n                if (address(0) == invitor) {\n                    break;\n                }\n            unchecked {\n                ++i;\n            }\n            }\n            user.isActive = true;\n        }\n    }\n\n       function getBinderList(address account, uint256 start, uint256 length) external view\n       returns (uint256 returnCount, address[] memory binders) {\n           address[] storage _binders = _binder[account];\n           uint256 recordLen = _binders.length;\n           if (0 == length) {\n               length = recordLen;\n           }\n           returnCount = length;\n           binders = new address[](length);\n           uint256 index = 0;\n           for (uint256 i = start; i < start + length; i++) {\n               if (i >= recordLen) {\n                   return (index, binders);\n               }\n               binders[index] = _binders[i];\n               index++;\n           }\n       }\n\n       function getDirectList(address account) external view\n       returns (address[] memory binders, uint256[] memory teamAmounts){\n           address[] storage _binders = referrals[account];\n           uint256 recordLen = _binders.length;\n           binders = new address[](recordLen);\n           teamAmounts = new uint256[](recordLen);\n           uint256 index = 0;\n           for (uint256 i = 0; i < recordLen; i++) {\n               if (i >= recordLen) {\n                   return (binders, teamAmounts);\n               }\n\n               address binder = _binders[i];\n               binders[index] = binder;\n               teamAmounts[index] = depositAmount[binder] + referralAmount[binder];\n               index++;\n           }\n       }\n\n\n    //    function getUserLPInfo(address account)\n    //    public\n    //    view\n    //    returns (\n    //        uint256 lockAmount,\n    //        uint256 calAmount,\n    //        uint256 claimedAmount,\n    //        uint256 lastReleaseTime,\n    //        uint256 releaseInitAmount,\n    //        uint256 releaseDuration,\n    //        uint256 speedUpTime,\n    //        uint256 tokenBalance,\n    //        uint256 tokenAllowance\n    //    ){\n    //        UserLPInfo storage userLPInfo = _userLPInfo[account];\n    //        lockAmount = userLPInfo.lockAmount;\n    //        calAmount = userLPInfo.calAmount;\n    //        claimedAmount = userLPInfo.claimedAmount;\n    //        releaseInitAmount = userLPInfo.releaseInitAmount;\n    //        releaseDuration = userLPInfo.releaseDuration;\n    //        speedUpTime = userLPInfo.speedUpTime;\n    //        lastReleaseTime = userLPInfo.lastReleaseTime;\n    //        tokenBalance = IERC20(_mintRewardToken).balanceOf(account);\n    //        tokenAllowance = IERC20(_mintRewardToken).allowance(\n    //            account,\n    //            address(this)\n    //        );\n    //    }\n\n    //    function getUserInfo(address account)\n    //    public\n    //    view\n    //    returns (\n    //        uint256 amount,\n    //        uint256 usdtBalance,\n    //        uint256 usdtAllowance,\n    //        uint256 pendingMintReward,\n    //        uint256 inviteAmount,\n    //        uint256 sellJoinAmount,\n    //        uint256 teamNum,\n    //        uint256 teamAmount\n    //    )\n    //    {\n    //        UserInfo storage user = userInfo[account];\n    //        amount = user.amount;\n    //        usdtBalance = IERC20(_usdt).balanceOf(account);\n    //        usdtAllowance = IERC20(_usdt).allowance(account, address(this));\n    //        pendingMintReward = getPendingMintReward(account) + user.calMintReward;\n    //        inviteAmount = _inviteAmount[account];\n    //        sellJoinAmount = _sellJoinAmount[account];\n    //        teamNum = _teamNum[account];\n    //        teamAmount = _teamAmount[account];\n    //    }\n\n    //    function getBaseInfo()\n    //    external\n    //    view\n    //    returns (\n    //        address usdt,\n    //        uint256 usdtDecimals,\n    //        address mintRewardToken,\n    //        uint256 mintRewardTokenDecimals,\n    //        uint256 totalUsdt,\n    //        uint256 totalAmount,\n    //        uint256 lastDailyReward,\n    //        uint256 dailyAmountRate,\n    //        uint256 minAmount,\n    //        address defaultInvitor,\n    //        bool pauseJoin\n    //    )\n    //    {\n    //        usdt = _usdt;\n    //        usdtDecimals = 18;\n    //        mintRewardToken = _mintRewardToken;\n    //        mintRewardTokenDecimals = 18;\n    //        totalUsdt = _totalUsdt;\n    //        totalAmount = poolInfo.totalAmount;\n    //        lastDailyReward = _lastDailyReward;\n    //        dailyAmountRate = getDailyRate();\n    //        minAmount = _minAmount;\n    //        defaultInvitor = _defaultInvitor;\n    //        pauseJoin = _pauseJoin;\n    //    }\n\n    //    function getLPInfo()\n    //    external\n    //    view\n    //    returns (\n    //        uint256 totalLP,\n    //        uint256 lockLP,\n    //        uint256 speedUpMaxTime,\n    //        uint256 speedCostUsdt,\n    //        uint256 speedCostToken\n    //    )\n    //    {\n    //        totalLP = IERC20(_lp).totalSupply();\n    //        lockLP = IERC20(_lp).balanceOf(address(this));\n    //        speedUpMaxTime = _speedUpMaxTime;\n    //        speedCostUsdt = _speedUpCost;\n    //        speedCostToken = getSpeedUpTokenAmount();\n    //    }\n\n\n    // ******** owner *********\n    function setNFTAddress(address _nftAddress) external onlyOwner {\n        _nft = INFT(_nftAddress);\n    }\n\n    function setUserLevel(address account, uint256 level) external onlyOwner {\n        userLevel[account] = level;\n    }\n\n    // Batch userInfo\n    function batchInsertUserInfo(address[] memory users, UserInfo[] memory userInfos) external onlyOwner {\n        require(users.length == userInfos.length, \"Array lengths do not match\");\n        for (uint256 i = 0; i < users.length; i++) {\n            userInfo[users[i]] = userInfos[i];\n        }\n    }\n\n    function setPauseSell(bool p) external onlyWhiteList {\n        _pauseSell = p;\n    }\n\n    function setSellSelfRate(uint256 r) external onlyWhiteList {\n        _sellSelfRate = r;\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"rate overflow\");\n    }\n\n    function setSellJoinRate(uint256 r) external onlyWhiteList {\n        _sellJoinRate = r;\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"rate overflow\");\n    }\n\n    function setSellNFTRate(uint256 r) external onlyWhiteList {\n        _sellNFTRate = r;\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"rate overflow\");\n    }\n\n    function setSellLPReceiver(address a) external onlyWhiteList {\n        _sellLPReceiver = a;\n    }\n\n    function setFundAddress(address a) external onlyWhiteList {\n        _fundAddress = a;\n    }\n\n    function setSpeedUpMaxTime(uint256 mt) external onlyWhiteList {\n        _speedUpMaxTime = mt;\n    }\n\n    function setSpeedUpCost(uint256 c) external onlyWhiteList {\n        _speedUpCost = c;\n    }\n\n    function setSpeedUpDuration(uint256 d) external onlyWhiteList {\n        _speedUpDuration = d;\n    }\n\n    function setSeedUpReceiver(address a) external onlyWhiteList {\n        _speedUpReceiver = a;\n    }\n\n    function setLPReleaseDuration(uint256 d) external onlyWhiteList {\n        require(d > 0, \"release duration must > 0\");\n        _lpReleaseDuration = d;\n    }\n\n    function setAmountDailyUp(uint256 r) external onlyWhiteList {\n        _amountDailyUp = r;\n    }\n\n    function setLastDailyUpTime(uint256 t) external onlyWhiteList {\n        _lastDailyUpTime = t;\n    }\n\n    function setLastAmountRate(uint256 r) external onlyWhiteList {\n        _lastAmountRate = r;\n    }\n\n    function open() external onlyWhiteList {\n        if (0 == _lastDailyUpTime) {\n            _lastDailyUpTime = block.timestamp;\n        }\n        _pauseJoin = false;\n    }\n\n    function close() external onlyWhiteList {\n        _pauseJoin = true;\n    }\n\n    function addMintAmount(address account, uint256 amount) external onlyWhiteList {\n        _bindInvitor(account, _defaultInvitor);\n        _updatePool();\n        _addUserAmount(account, amount, false);\n    }\n\n    function setMintPerSec(uint256 mintPerSec) external onlyWhiteList {\n        _updatePool();\n        poolInfo.mintPerSec = mintPerSec;\n    }\n\n    function setInviteFee(uint256 i, uint256 fee) external onlyWhiteList {\n        _inviteFee[i] = fee;\n    }\n\n    function claimBalance(address to, uint256 amount) external onlyWhiteList {\n        safeTransferETH(to, amount);\n    }\n\n    function claimToken(address token, address to, uint256 amount) external onlyWhiteList {\n        _giveToken(token, to, amount);\n    }\n\n    function setDefaultInvitor(address adr) external onlyWhiteList {\n        _defaultInvitor = adr;\n        userInfo[adr].isActive = true;\n    }\n\n    function setInProject(address adr, bool enable) external onlyWhiteList {\n        _inProject[adr] = enable;\n    }\n\n    function addTotalMintReward(uint256 reward) external onlyInProject {\n        _updatePool();\n        poolInfo.totalMintReward += reward;\n        poolInfo.mintPerSec = reward / _dailyDuration;\n        _lastDailyReward = reward;\n    }\n\n    function bindInvitor(address account, address invitor) public onlyInProject {\n        _bindInvitor(account, invitor);\n    }\n\n   function bindInvitors(address[] memory account, address[] memory invitor) public onlyInProject {\n       for (uint256 i = 0; i < account.length; i++) {\n           _bindInvitor(account[i], invitor[i]);\n       }\n   }\n\n    function addUserAmount(address account, uint256 amount, bool calInvite) public onlyInProject {\n        _bindInvitor(account, _defaultInvitor);\n        _updatePool();\n        _addUserAmount(account, amount, calInvite);\n    }\n\n\n    // ******** utils *********\n    function safeApprove(address token, address to, uint256 value) internal {\n        //bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"approve fail\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value : value}(new bytes(0));\n        require(success, \"eth transfer fail\");\n    }\n\n    function _giveToken(address tokenAddress, address account, uint256 amount) private {\n        if (0 == amount) {\n            return;\n        }\n        IERC20 token = IERC20(tokenAddress);\n        require(token.balanceOf(address(this)) >= amount, \"balance not enough\");\n        token.transfer(account, amount);\n    }\n\n    function _takeToken(address tokenAddress, address from, address to, uint256 tokenNum) private {\n        IERC20 token = IERC20(tokenAddress);\n        require(token.balanceOf(address(from)) >= tokenNum, \"balance not enough\");\n        token.transferFrom(from, to, tokenNum);\n    }\n\n    // ********* setting *********\n    function setPoolInfo(uint256 totalAmount, uint256 accMintPerShare, uint256 accMintReward, uint256 mintPerSec,\n        uint256 lastMintTime, uint256 totalMintReward) external onlyWhiteList {\n        poolInfo.totalAmount = totalAmount;\n        poolInfo.accMintPerShare = accMintPerShare;\n        poolInfo.accMintReward = accMintReward;\n        poolInfo.mintPerSec = mintPerSec;\n        poolInfo.lastMintTime = lastMintTime;\n        poolInfo.totalMintReward = totalMintReward;\n    }\n\n    function setUserLpInfos(address[] memory account, UserLPInfo[] memory lpInfos) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            _userLPInfo[account[i]] = lpInfos[i];\n        }\n    }\n\n    function setInviteAmount(address[] memory account, uint256[] memory amount) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            _inviteAmount[account[i]] = amount[i];\n        }\n    }\n\n    function setTeamAmount(address[] memory account, uint256[] memory amount) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            _teamAmount[account[i]] = amount[i];\n        }\n    }\n\n    function setSellJoinAmount(address[] memory account, uint256[] memory amount) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            _sellJoinAmount[account[i]] = amount[i];\n        }\n    }\n\n    function setReferralAmount(address[] memory account, uint256[] memory amount) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            referralAmount[account[i]] = amount[i];\n        }\n    }\n\n    function setDepositAmount(address[] memory account, uint256[] memory amount) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            depositAmount[account[i]] = amount[i];\n        }\n    }\n\n    function setReferralReward(address[] memory account, uint256[] memory amount) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            referralReward[account[i]] = amount[i];\n        }\n    }\n\n    function setUserLevels(address[] memory account, uint256[] memory level) external onlyWhiteList {\n        for (uint256 i = 0; i < account.length; i++) {\n            userLevel[account[i]] = level[i];\n        }\n    }\n\n    function setTotalUsd(uint256 amount) external onlyWhiteList {\n        _totalUsdt = amount;\n    }\n\n    function setLastDailyReward(uint256 reward) external onlyWhiteList {\n        _lastDailyReward = reward;\n    }\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\t/// @solidity memory-safe-assembly\n\t\tassembly {\n\t\t\tpop(staticcall(gas(), consoleAddress, add(payload, 32), mload(payload), 0, 0))\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}